# CSS 预处理器

## Sass

> Sass 是一款强化 CSS 的辅助工具，它在 CSS 语法的基础上增加了变量 (variables)、嵌套 (nested rules)、混合 (mixins)、导入 (inline imports) 等高级功能，这些拓展令 CSS 更加强大与优雅。使用 Sass 以及 Sass 的样式库（如 [Compass](http://compass-style.org/)）有助于更好地组织管理样式文件，以及更高效地开发项目。

### 特色功能 (Features)

- 完全兼容 CSS3
- 在 CSS 基础上增加变量、嵌套 (nesting)、混合 (mixins) 等功能
- 通过[函数](http://sass-lang.com/docs/yardoc/Sass/Script/Functions.html)进行颜色值与属性值的运算
- 提供[控制指令 (control directives)](https://www.sass.hk/docs/#t8)等高级功能
- 自定义输出格式

### 语法格式 (Syntax)

Sass 有两种语法格式。首先是 SCSS (Sassy CSS) —— 也是本文示例所使用的格式 —— 这种格式仅在 CSS3 语法的基础上进行拓展，所有 CSS3 语法在 SCSS 中都是通用的，同时加入 Sass 的特色功能。此外，SCSS 也支持大多数 CSS hacks 写法以及浏览器前缀写法 (vendor-specific syntax)，以及早期的 IE 滤镜写法。这种格式以 `.scss` 作为拓展名。

另一种也是最早的 Sass 语法格式，被称为缩进格式 (Indented Sass) 通常简称 "Sass"，是一种简化格式。它使用 “缩进” 代替 “花括号” 表示属性属于某个选择器，用 “换行” 代替 “分号” 分隔属性，很多人认为这样做比 SCSS 更容易阅读，书写也更快速。缩进格式也可以使用 Sass 的全部功能，只是与 SCSS 相比个别地方采取了不同的表达方式，具体请查看 [the indented syntax reference](http://sass-lang.com/docs/yardoc/file.INDENTED_SYNTAX.html)。这种格式以 `.sass` 作为拓展名。

任何一种格式可以直接 [导入 (@import)](https://www.sass.hk/docs/#t7-1) 到另一种格式中使用，或者通过 `sass-convert` 命令行工具转换成另一种格式：

```Shell
# Convert Sass to SCSS
$ sass-convert style.sass style.scss

# Convert SCSS to Sass
$ sass-convert style.scss style.sass
```

关于 sass 和 scss 的区别：

参考文献：[SCSS 和 Sass 有什么区别？](https://blog.csdn.net/kalman2019/article/details/128587105)

- 语法差异，scss 使用是 css3 的语法，sass 是 ruby 语法
- 文件后缀差异
- 可以相互转换

### 使用 Sass (Using Sass)

[安装 ruby](https://blog.csdn.net/sinat_40572875/article/details/127969655)

Sass 可以通过以下三种方式使用：作为命令行工具；作为独立的 Ruby 模块 (Ruby module)；或者作为 Rack-enabled 框架的插件（例如 Ruby on Rails 与 Merb）。无论哪种方式都需要先安装 Sass gem （Windows 系统需要先[安装 Ruby](http://rubyinstaller.org/)）：

```Plaintext
gem install sass
```

在命令行中运行 Sass：

```Plaintext
sass input.scss output.css
```

监视单个 Sass 文件，每次修改并保存时自动编译：

```Plaintext
sass --watch input.scss:output.css
```

监视整个文件夹：

```Plaintext
sass --watch app/sass:public/stylesheets
```

更多命令的用法请通过 `sass --help` 获取帮助。

在 Ruby 中使用 Sass 也非常容易，Sass gem 安装完毕后运行 `require "sass"` 然后按照下面的方法使用 [Sass::Engine](http://sass-lang.com/docs/yardoc/Sass/Engine.html)：

```Plaintext
engine = Sass::Engine.new("#main {background-color: #0000ff}", :syntax => :scss)
engine.render #=> "#main { background-color: #0000ff; }\n"
```

### 功能扩展

#### 嵌套规则 (Nested Rules)

#### 父级选择器&

#### 属性嵌套

有些 CSS 属性遵循相同的命名空间 (namespace)，比如 `font-family, font-size, font-weight` 都以 `font` 作为属性的命名空间。为了便于管理这样的属性，同时也为了避免了重复输入，Sass 允许将属性嵌套在命名空间中，例如：

```Plaintext
.funky {
  font: {
    family: fantasy;
    size: 30em;
    weight: bold;
  }
}
```

编译为

```Plaintext
.funky {
  font-family: fantasy;
  font-size: 30em;
  font-weight: bold; }
```

命名空间也可以包含自己的属性值，例如：

```Plaintext
.funky {
  font: 20px/24px {
    family: fantasy;
    weight: bold;
  }
}
```

编译为

```Plaintext
.funky {
  font: 20px/24px;
    font-family: fantasy;
    font-weight: bold; }
```

#### 占位符选择器

Sass 额外提供了一种特殊类型的选择器：占位符选择器 (placeholder selector)。与常用的 id 与 class 选择器写法相似，只是 `#` 或 `.` 替换成了 `%`。必须通过 [@extend](https://www.sass.hk/docs/#t7-3) 指令调用，更多介绍请查阅 [@extend-Only Selectors](https://www.sass.hk/docs/#t7-3-6)。

当占位符选择器单独使用时（未通过 `@extend` 调用），不会编译到 CSS 文件中。

#### 注释

Sass 支持标准的 CSS 多行注释 `/* */`，以及单行注释 `//`，前者会 被完整输出到编译后的 CSS 文件中，而后者则不会

将 `!` 作为多行注释的第一个字符表示在压缩输出模式下保留这条注释并输出到 CSS 文件中，通常用于添加版权信息。

插值语句 (interpolation) 也可写进多行注释中输出变量值

```Plaintext
$version: "1.2.3";
/* This CSS is generated by My Snazzy Framework version #{$version}. */
```

编译为

```Plaintext
/* This CSS is generated by My Snazzy Framework version 1.2.3. */
```

#### 变量

SassScript 最普遍的用法就是变量，变量以美元符号开头，赋值方法与 CSS 属性的写法一样：

```Plaintext
$width: 5em;
```

直接使用即调用变量：

```Plaintext
#main {
  width: $width;
}
```

变量支持块级作用域，嵌套规则内定义的变量只能在嵌套规则内使用（局部变量），不在嵌套规则内定义的变量则可在任何地方使用（全局变量）。将局部变量转换为全局变量可以添加 `!global` 声明：

```Plaintext
#main {
  $width: 5em !global;
  width: $width;
}

#sidebar {
  width: $width;
}
```

编译为

```Plaintext
#main {
  width: 5em;
}

#sidebar {
  width: 5em;
}
```

##### 变量定义 !default

可以在变量的结尾添加 `!default` 给一个未通过 `!default` 声明赋值的变量赋值，此时，如果变量已经被赋值，不会再被重新赋值，但是如果变量还没有被赋值，则会被赋予新的值。

```Plaintext
$content: "First content";
$content: "Second content?" !default;
$new_content: "First time reference" !default;

#main {
  content: $content;
  new-content: $new_content;
}
```

编译为

```Plaintext
#main {
  content: "First content";
  new-content: "First time reference"; }
```

变量是 null 空值时将视为未被 `!default` 赋值。

```Plaintext
$content: null;
$content: "Non-null content" !default;

#main {
  content: $content;
}
```

编译为

```Plaintext
#main {
  content: "Non-null content"; }
```

#### @-Rules 与指令 (@-Rules and Directives)

##### @import

通常，`@import` 寻找 Sass 文件并将其导入，但在以下情况下，`@import` 仅作为普通的 CSS 语句，不会导入任何 Sass 文件。

- 文件拓展名是 `.css`；
- 文件名以 `http://` 开头；
- 文件名是 `url()`；
- `@import` 包含 media queries。

```Plaintext
@import "foo.css";
@import "foo" screen;
@import "http://foo.com/bar";
@import url(foo);
```

编译为

```Plaintext
@import "foo.css";
@import "foo" screen;
@import "http://foo.com/bar";
@import url(foo);
```

支持同时导入多个 sass/scss，中间用 ' , ' 隔开

##### @extend

```SCSS
.error {
  border: 1px #f00;
  background-color: #fdd;
}
.error.intrusion {
  background-image: url("/image/hacked.png");
}
.seriousError {
  @extend .error;
  border-width: 3px;
}

// 编译后
.error, .seriousError {
  border: 1px #f00;
  background-color: #fdd; }

.error.intrusion, .seriousError.intrusion {
  background-image: url("/image/hacked.png"); }

.seriousError {
  border-width: 3px; }
```

##### @extend-only 选择器

有时，需要定义一套样式并不是给某个元素用，而是只通过 `@extend` 指令使用，尤其是在制作 Sass 样式库的时候，希望 Sass 能够忽略用不到的样式。

如果使用普通的 CSS 规则，最后会编译出很多用不到的样式，也容易与其他样式名冲突，所以，Sass 引入了“占位符选择器” (placeholder selectors)，看起来很像普通的 `id` 或 `class` 选择器，只是 `#` 或 `.` 被替换成了 `%`。可以像 class 或者 id 选择器那样使用，当它们单独使用时，不会被编译到 CSS 文件中。

```Plaintext
// This ruleset won't be rendered on its own.
#context a%extreme {
  color: blue;
  font-weight: bold;
  font-size: 2em;
}
```

占位符选择器需要通过延伸指令使用，用法与 class 或者 id 选择器一样，被延伸后，占位符选择器本身不会被编译。

```Plaintext
.notice {
  @extend %extreme;
}
```

编译为

```Plaintext
#context a.notice {
  color: blue;
  font-weight: bold;
  font-size: 2em; }
```

#### 控制指令

##### @if

当 `@if` 的表达式返回值不是 `false` 或者 `null` 时，条件成立，输出 `{}` 内的代码：

```Plaintext
p {
  @if 1 + 1 == 2 { border: 1px solid; }
  @if 5 < 3 { border: 2px dotted; }
  @if null  { border: 3px double; }
}
```

编译为

```Plaintext
p {
  border: 1px solid; }
```

`@if` 声明后面可以跟多个 `@else if` 声明，或者一个 `@else` 声明。如果 `@if` 声明失败，Sass 将逐条执行 `@else if` 声明，如果全部失败，最后执行 `@else` 声明，例如：

```Plaintext
$type: monster;
p {
  @if $type == ocean {
    color: blue;
  } @else if $type == matador {
    color: red;
  } @else if $type == monster {
    color: green;
  } @else {
    color: black;
  }
}
```

编译为

```Plaintext
p {
  color: green; }
```

##### @for

`@for` 指令可以在限制的范围内重复输出格式，每次按要求（变量的值）对输出结果做出变动。这个指令包含两种格式：`@for $var from <start> through <end>`，或者 `@for $var from <start> to <end>`，区别在于 `through` 与 `to` 的含义：_当使用_ _`through`_ _时，条件范围包含_ _`<start>`_ _与_ _`<end>`_ _的值，而使用_ _`to`_ _时条件范围只包含_ _`<start>`_ _的值不包含_ _`<end>`_ _的值_。另外，`$var` 可以是任何变量，比如 `$i`；`<start>` 和 `<end>` 必须是整数值。

```SCSS
.content {
  @for $i from 1 to 3 {
    .item-#{$i} {
      width: 2em * $i;
    }
  }
}

/*
  @for $i from start through end {} // [start, end]闭区间

  @for $i from start to end {} // [start, end) 左闭右开区间

  编译之后：

  .content .item-1 {
  width: 2em; }
  .content .item-2 {
  width: 4em; }

*/
```

##### @each

`@each` 指令的格式是 `$var in <list>`, `$var` 可以是任何变量名，比如 `$length` 或者 `$name`，而 `<list>` 是一连串的值，也就是值列表。

`@each` 将变量 `$var` 作用于值列表中的每一个项目，然后输出结果，例如：

```Plaintext
@each $animal in puma, sea-slug, egret, salamander {
  .#{$animal}-icon {
    background-image: url('/images/#{$animal}.png');
  }
}
```

编译为

```Plaintext
.puma-icon {
  background-image: url('/images/puma.png'); }
.sea-slug-icon {
  background-image: url('/images/sea-slug.png'); }
.egret-icon {
  background-image: url('/images/egret.png'); }
.salamander-icon {
  background-image: url('/images/salamander.png'); }
```

The @each directive can also use multiple variables, as in @each $var1, $var2, ... in . If is a list of lists, each element of the sub-lists is assigned to the respective variable. For example:

(@each 可以分配给多个变量)

```Plaintext
@each $animal, $color, $cursor in (puma, black, default),
                                  (sea-slug, blue, pointer),
                                  (egret, white, move) {
  .#{$animal}-icon {
    background-image: url('/images/#{$animal}.png');
    border: 2px solid $color;
    cursor: $cursor;
  }
}
```

is compiled to:

```Plaintext
.puma-icon {
  background-image: url('/images/puma.png');
  border: 2px solid black;
  cursor: default; }
.sea-slug-icon {
  background-image: url('/images/sea-slug.png');
  border: 2px solid blue;
  cursor: pointer; }
.egret-icon {
  background-image: url('/images/egret.png');
  border: 2px solid white;
  cursor: move; }
```

Since maps are treated as lists of pairs, multiple assignment works with them as well. For example:

```Plaintext
@each $header, $size in (h1: 2em, h2: 1.5em, h3: 1.2em) {
  #{$header} {
    font-size: $size;
  }
}
```

is compiled to:

```Plaintext
h1 {
  font-size: 2em; }
h2 {
  font-size: 1.5em; }
h3 {
  font-size: 1.2em; }
```

##### @while

`@while` 指令重复输出格式直到表达式返回结果为 `false`。这样可以实现比 `@for` 更复杂的循环，只是很少会用到。例如：

```Plaintext
$i: 6;
@while $i > 0 {
  .item-#{$i} { width: 2em * $i; }
  $i: $i - 2;
}
.item-6 {
  width: 12em; }

.item-4 {
  width: 8em; }

.item-2 {
  width: 4em; }
```

##### @mixin 与 @include

混合指令（Mixin）用于定义可重复使用的样式，避免了使用无语意的 class，比如 `.float-left`。混合指令可以包含所有的 CSS 规则，绝大部分 Sass 规则，甚至通过参数功能引入变量，输出多样化的样式。

```SCSS
// 使用继承
// .box {
//   color: red;
// }

// .content {
//   color: green;
//   @extend .box;
// }

/*
.box, .content {
  color: red; }

.content {
  color: green; }

*/

// 使用混合
// 混合指令的用法是在 @mixin 后添加名称与样式，比如名为 large-text 的混合通过下面的代码定义：
@mixin box {
  display: block;
  width: 100px;
  height: 100px;
}

.content {
// 使用 @include 指令引用混合样式，格式是在其后添加混合名称，以及需要的参数（可选）：
  @include box;
  width: 200px;
  height: 200px;
}

/*
编译结果
.content {
  display: block;
  width: 100px;
  height: 100px;
  width: 200px;
  height: 200px; }
*/
```

使用参数(还可以设置默认值 $i: 100px )

```SCSS
@mixin box($i, $j) {
  display: block;
  width: $i;
  height: $j;
}

.content {
  @include box(100px, 200px);
}
```

##### @function

```SCSS
$large-width: 200px;

$middle-width: 100px;

@function get-width($width) {
  @if $width % 2 == 0 {
    @return $large-width * $width;
  }
  @return $middle-width * $width;
}

.content {
  width: get-width(2);
}

.box {
  width: get-width(1);
}
```

1. ### How to Share Variables Between Javascript and Sass

> https://www.bluematador.com/blog/how-to-share-variables-between-js-and-sass

The first step is to install our dependencies:

```Bash
npm install sass-loader node-sass webpack --save-dev
```

Next, we need to configure webpack to use `sass-loader` so we can access our Sass code from Javascript.

```JavaScript
// webpack.config.js
module.exports = {
  module: {
    rules: [{
        test: /\.css$/,
        use: ['style-loader', 'css-loader', 'sass-loader']
        }]
  }
}
```

Now for the interesting part. We define the actual variable value in Sass and export it to Javascript. CSS Modules have a neat utility called `:export`. The `:export` directive works basically like ES6’s `export` keyword. Your Sass code will export an object containing the variable name to use in Javascript and its associated value. These values are all exported as strings.

```SCSS
// styles/animation.scss
$animation-length: 250;
$animation-length-ms: $animation-length + 0ms;
:export {
animationMillis: $animation-length-ms;
}
.component-enter {
  ...
  transition: all $animation-length-ms ease-in;
}
```

You’ll notice that we first declare the integer value in one variable, and then add `0ms` to it in other. This allows us to export only `"250"` rather than `"250ms"` which is a little easier to parse on the Javascript side (adding `0ms` to the number coerces its “type” into `ms`).

Now, in Javascript, we just need to import the styles from the stylesheet, and parse an int out of the variable we exported!

```JavaScript
// js/animation.js
import styles from '../styles/animation.scss'
import CSSTransitionGroup from 'react-transition-group/CSSTransitionGroup'
const millis = parseInt(styles.animationMillis)
...
<CSSTransitionGroup
  transitionName="component"
  transitionEnterTimeout={millis}
  transitionLeaveTimeout={millis}/>
...
```

This method is incredibly easy, but it will pay off in spades when you avoid the headache of syncing changes between Javascript and Sass.
